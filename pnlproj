#!/usr/bin/env python
from plumbum import cli, local, FG
import csv
import yaml
from collections import OrderedDict
import sys
from os.path import getmtime
import os
from plumbum.cmd import scp
import pandas as pd
import pnlproj_lib.csvs
import pnlproj_lib.extra
import find

PROJECT_YML = local.path('project.yml')
PNL_PROJECTS_DB = 'PNL_PROJECTS_DB'
CACHE_DIR = local.path("_pnlproj")
PATHS_CSV = local.path(CACHE_DIR / "paths.csv")
PARAMS_CSV = local.path(CACHE_DIR / "params.csv")
FIND_TXT = local.path(CACHE_DIR / "findPaths.txt")
DU_CSV = local.path(CACHE_DIR / "du.csv")
EXTRA_CSV = local.path(CACHE_DIR / "diffPaths.csv")
FIND_EXTS = ['.nrrd', '.nii.gz', '.nii', '.vtk', '.nhdr', '.mgz']

TEMPLATE = """\
projectInfo:
    grantId:
    description: |
                 Meaning of path keys:
                 fs - freesurfer subject directory
                 dwied: eddy corrected DWI
                 dwimask: FSL bet generated DWI mask
                 etc.
pipelines:
    - parameters:
        version_FreeSurfer: 5.3.0
        hash_UKFTractography: 421a7ad
        hash_tract_querier: e045eab
        hash_BRAINSTools: 41353e8
        hash_trainingDataT1AHCC: d6e5990
      paths:
        fs: _data/003_GNX_007/freesurfer/*/*
        dwied: _data/003_GNX_007/std_dwied0.nrrd
        dwimask: _data/003_GNX_007/std_dwimask0.nrrd
        t1mask: _data/003_GNX_007/std_t1mask0.nrrd
        t1: _data/003_GNX_007/std_t10.nrrd
        wmql: _data/003_GNX_007/wmql/*.vtk
        tractmeasures: _data/003_GNX_007/std_tractmeasures0.csv
        dwixc: _data/003_GNX_007/std_dwixc0.nrrd
        ukf: _data/003_GNX_007/std_ukf0.vtk
        t1xc: _data/003_GNX_007/std_t1xc0.nrrd
        fsindwi: _data/003_GNX_007/std_fsindwi0.nii.gz
        dwi: _data/003_GNX_007/std_dwi0.nhdr
        caseid: 003_GNX_007
        caselist: ./caselist.txt
""".format(local.cwd.name.__str__())


class App(cli.Application):

    def main(self, *args):
        if args:
            print("Unknown command {0!r}".format(args[0]))
            return 1
        if self.nested_command:
            return


@App.subcommand("init")
class Init(cli.Application):
    """Makes template 'project.yml'"""

    force = cli.Flag(['-f', '--force'], default=False, help='force overwrite')

    def main(self):
        if local.path(PROJECT_YML).exists() and not self.force:
            msg = "'{}' already exists, to recreate it delete it first or use --force flag.".format(PROJECT_YML)
            print(msg)
            sys.exit(1)

        represent_dict_order = lambda self, data: self.represent_mapping('tag:yaml.org,2002:map', data.items())
        yaml.add_representer(OrderedDict, represent_dict_order)

        with open(PROJECT_YML, 'w') as f:
            f.write(TEMPLATE)
        print("Made template '{}'.".format(PROJECT_YML))


@App.subcommand("push")
class Push(cli.Application):
    """Copies project.yml and _pnlproj/* to central project database"""

    def main(self):

        centralRepo = os.environ.get(PNL_PROJECTS_DB, None)

        if not centralRepo:
            errmsg = "Set '{}' environment variable first.".format(
                PNL_PROJECTS_DB)
            raise Exception(errmsg)

        destDir = local.path(centralRepo) / local.cwd.__str__().replace('/', '---')[3:]
        destDir.mkdir()

        files = ['project.yml', PATHS_CSV, PARAMS_CSV, EXTRA_CSV, DU_CSV]
        for file in files:
            scp[file, destDir] & FG
            print("Copied '{}' to '{}'".format(file, destDir))


class Csvs(cli.Application):
    """Generates _pnlproj/paths.csv and _pnlproj/params.csv from project.yml"""

    useCache = cli.Flag(['-c', '--cache'], default=False, mandatory=False, help="Use cached results \
to avoid recomputing paths.csv")

    def main(self):
        if not self.useCache or not PATHS_CSV.exists() or (getmtime(PROJECT_YML) > getmtime(PATHS_CSV)):
            pnlproj_lib.csvs.csvs(PROJECT_YML, CACHE_DIR)
        else:
            print(
                "'{}' is newer than '{}', so not regenerating.".format(
                    PATHS_CSV, PROJECT_YML))


@App.subcommand("find")
class Find(cli.Application):
    """Finds all image files in the project directory and saves result to _pnlproj/findPaths.txt."""

    def main(self):
        find.Find.invoke(PROJECT_YML.dirname, out = FIND_TXT)
        from plumbum.cmd import du
        diskUsageG = float(du('-sb').split()[0])/1024.0/1024.0/1024.0
        with open(DU_CSV, 'w') as f:
            f.write("projectPath,diskUsageG\n")
            f.write('"{}",{}'.format(PROJECT_YML.dirname, diskUsageG))
        print("Made '{}'".format(DU_CSV))


@App.subcommand("extra")
class Extra(cli.Application):
    """Lists the extra image files that are not accounted for in project.yml."""

    ls = cli.Flag(['-l', '--ls'], default=False, help="List extra files")

    def main(self):
        Csvs.invoke()
        if not FIND_TXT.exists():
            Find.invoke()
        else:
            print("'{}' already exists, using that to find unaccounted files (run 'pnlproj find' to update it).".format(FIND_TXT))
        pnlproj_lib.extra.extra(PATHS_CSV, FIND_TXT, EXTRA_CSV, self.ls)


def heading(s):
    return s + '\n' + len(s) * '-'

@App.subcommand("status")
class Summary(cli.Application):
    """Prints a summary of the project disk usage."""

    def main(self):
        Extra.invoke()

        pd.options.display.float_format = '{:,.2f}'.format

        paths = pd.read_csv(PATHS_CSV)
        extraFiles = pd.read_csv(EXTRA_CSV)
        du = pd.read_csv(DU_CSV)

        agg = { 'path': 'count', 'sizeMB': 'sum'}
        st = paths.groupby(['pipelineId', 'exists']).agg(agg)
        st['sizeMB'] = st['sizeMB']/1024.0/1024.0
        st.rename(columns={'sizeMB':'size(G)', 'path':'count'}, inplace=True)
        st.reset_index(level=st.index.names, inplace=True)
        print(heading('Pipeline Files'))
        print(st.to_string(index=False))
        pipelineDiskUsage = paths['sizeMB'].sum() / 1024.0
        print("total: {:.2f}G".format(pipelineDiskUsage))
        totalDiskUsage = du['diskUsageG'].iloc[0]
        print("directory size: {:.2f}G".format(totalDiskUsage))

if __name__ == '__main__':
    CACHE_DIR.mkdir()

    App.run()
