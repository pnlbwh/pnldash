#!/usr/bin/env python

import sys
from plumbum import cli, local, FG, SshMachine
from pnldash_lib import read_project_yml, read_yml
import pnldash_config as config
from pnldash_config import *
import pandas as pd
from pprint import pprint
import pnldash_lib.db as db
from plumbum.path.utils import copy
import logging
logging.basicConfig(
            level=logging.INFO,
            # format='%(asctime)s - %(levelname)5s - %(name)s:  %(message)s',
            format='%(levelname)s:%(name)s: %(message)s',
            datefmt="%Y-%m-%d %H:%M")
log = logging.getLogger(__name__)


def _stack_csvs(csvs, out):
    if not csvs:
        raise Exception("Expect at least one csv")
    if not all(csv.exists() for csv in csvs):
        print csvs
        raise Exception("Not all csvs exist")
    dfs = [pd.read_csv(csv) for csv in csvs]
    pd.concat(dfs).to_csv(str(out), index=False)
    log.info("Made '{}'".format(out))


class App(cli.Application):
    def main(self, *args):
        if args:
            print("Unknown command {0!r}".format(args[0]))
            return 1
        if not self.nested_command:
            print("No command given")
            return 1  # error exit code


@App.subcommand("make")
class Make(cli.Application):
    """Make HTML dashboard report."""

    dbpath = cli.SwitchAttr(['--db'], cli.ExistingDirectory,
                            help="use this local database path")

    def main(self, *args):
        dbdir = self.dbpath or db.get_db_dir()

        url = db.spliturl(dbdir)
        if url.scheme: # if remote database
            user, host, remotepath, port = (url.username, url.hostname, url.path, url.port)
            print('host: {host}, user: {user}, port: {port}, path: {remotepath}'.format(**locals()))
            log.info('Log into remote and make dashboard')
            with SshMachine(host, user=user, port=port) as rem:
                _ = rem['pnldashdb']('make', '--db', remotepath)
                copy(rem.path('pnldashboard.html'), local.cwd)
            # scphost = '{user}@{host}'.format(**locals())
            log.info('Copy dashboard to current directory')
            # from plumbum.cmd import scp
            # scp('-P', port, scphost + ':pnldashboard.html', local.cwd)
            log.info("Made 'pnldashboard.html'")
        else:
            dbprojectdirs = db.get_db_project_dirs()
            pathcsvs = [pd / (PATHS_CSV.name) for pd in dbprojectdirs]
            paramcsvs = [pd / (PARAMS_CSV.name) for pd in dbprojectdirs]
            extracsvs = [pd / (EXTRA_CSV.name) for pd in dbprojectdirs]
            ducsvs = [pd / (DU_CSV.name) for pd in dbprojectdirs]
            _stack_csvs(pathcsvs, dbdir / 'paths.csv')
            _stack_csvs(paramcsvs, dbdir / 'params.csv')
            _stack_csvs(extracsvs, dbdir / 'diffPaths.csv')
            _stack_csvs(ducsvs, dbdir / 'du.csv')

            from plumbum.cmd import R
            thisdir = local.path(__file__).dirname
            print("Make dashboard")
            (thisdir / 'pnldashboard.Rmd').copy(dbdir)
            R['-e',
              "library('rmarkdown'); setwd('{}'); render('pnldashboard.Rmd', output_dir='{}')".format(
                  dbdir, local.cwd)] & FG



@App.subcommand("update")
class Update(cli.Application):
    """Update the central project database."""

    find = cli.SwitchAttr(
        ['--find'],
        help='Crawl project directories for image files instead of using previously cached result')

    def main(self, *args):
        from plumbum.cmd import pnldash
        dbdir = db.get_db_dir()
        projectdirs = db.get_project_dirs()
        for projectdir in projectdirs:
            print("Updating '{}'".format(projectdir))
            with local.cwd(projectdir):
                if self.find:
                    pnldash('find')
                pnldash('status')
                pnldash('push')


def _print_map(d, prepend='', keys=None, fd=sys.stderr):
    if not keys:
        keys = d.keys()
    for k in keys:
        fd.write("{}{:<25} {:<15}".format(prepend, k, d[k]) + '\n')


@App.subcommand("env")
class Env(cli.Application):
    """Print the bash environment setup for a project's data paths."""

    paramid = cli.SwitchAttr(
        ['-p', '--paramid'],
        int,
        default=0,
        help="The index of the pipeline whose paths you want")

    #TODO make unset option?

    def main(self, name):
        def escape(filepath):
            return filepath.__str__().replace('(', '\(').replace(')', '\)')

        # TODO be able to select projects with same names
        projectdir, yml = db.get_projects(name)[0]

        print("# param id #{} (there are a total of {} pipeline(s))".format(
            self.paramid, len(yml['pipelines'])))
        _print_map(yml['pipelines'][self.paramid]['parameters'], prepend='# ')
        print('')
        print("export root={}".format(projectdir))
        paths = yml['pipelines'][self.paramid]['paths']
        for key, path in paths.items():
            if key == 'caselist':
                continue
            print("export {}={}".format(key, escape(path)))


@App.subcommand("list")
class List(cli.Application):
    """List the project names in the central database"""

    def main(self):
        for projectdir, yml in db.get_projects():
            numpipelines = len(yml['pipelines'])
            print(yml['name'] + " ({}) ({} pipeline(s))".format(projectdir,
                                                                numpipelines))


@App.subcommand("show")
class Show(cli.Application):
    """Show the project.yml contents for a project."""

    def main(self, name):
        # TODO be able to select projects with same names
        projectdir, yml = db.get_projects(name)[0]
        print("# {} ({})".format(yml['name'], projectdir))
        print
        print("## Description\n")
        print(yml['description\n'])
        print("## Pipelines\n")
        pprint(yml['pipelines'])


if __name__ == '__main__':
    App.run()
