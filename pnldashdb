#!/usr/bin/env python

import sys
from plumbum import cli, local, FG
from pnldash_lib import read_project_yml, read_yml
import pnldash_config as config
from pnldash_config import *
import pandas as pd
from pprint import pprint
import pnldash_lib.db as db


def _stack_csvs(csvs, out):
    if not csvs:
        raise Exception("Expect at least one csv")
    if not all(csv.exists() for csv in csvs):
        print csvs
        raise Exception("Not all csvs exist")
    dfs = [pd.read_csv(csv) for csv in csvs]
    pd.concat(dfs).to_csv(str(out), index=False)
    print("Made '{}'".format(out))


class App(cli.Application):
    def main(self, *args):
        if args:
            print("Unknown command {0!r}".format(args[0]))
            return 1
        if not self.nested_command:
            print("No command given")
            return 1  # error exit code


def _spliturl(url):
    user, host_port_path = url.split('@')
    host, port_path = host_port_path.split(':')
    if port_path.startswith('/'):  # no port
        return (user, host, port_path, None)
    port, path = port_path.split('/', 1)
    return (user, host, '/' + path, port)


@App.subcommand("make")
class Make(cli.Application):
    """Make HTML dashboard report."""

    dbpath = cli.SwitchAttr(['--db'], cli.ExistingDirectory,
                            help="use this local database path")

    def main(self, *args):
        dbdir = self.dbpath or db.get_db_dir()

        # if remote database
        if '@' in dbdir:
            user, host, remotepath, port = _spliturl(dbdir)
            with SshMachine(host, user=user, port=port) as rem:
                rem['pnldashdb']('make', '--db', remotepath)
            scphost = '{user}@{host}:{remotepath}'.format(**locals())
            scp[scphost + '/pnldashboard.html', local.cwd]
            log.info("Made 'pnldashboard.html'")
        else:
            dbprojectdirs = db.get_db_project_dirs()
            pathcsvs = [pd / (PATHS_CSV.name) for pd in dbprojectdirs]
            paramcsvs = [pd / (PARAMS_CSV.name) for pd in dbprojectdirs]
            extracsvs = [pd / (EXTRA_CSV.name) for pd in dbprojectdirs]
            ducsvs = [pd / (DU_CSV.name) for pd in dbprojectdirs]
            _stack_csvs(pathcsvs, dbdir / 'paths.csv')
            _stack_csvs(paramcsvs, dbdir / 'params.csv')
            _stack_csvs(extracsvs, dbdir / 'diffPaths.csv')
            _stack_csvs(ducsvs, dbdir / 'du.csv')

            from plumbum.cmd import R
            thisdir = local.path(__file__).dirname
            print("Make dashboard")
            R['-e',
              "library('rmarkdown'); setwd('{}'); render('pnldashboard.Rmd', output_dir='{}')".format(
                  thisdir, local.cwd)] & FG


@App.subcommand("update")
class Update(cli.Application):
    """Update the central project database."""

    find = cli.SwitchAttr(
        ['--find'],
        help='Crawl project directories for image files instead of using previously cached result')

    def main(self, *args):
        from plumbum.cmd import pnldash
        dbdir = db.get_db_dir()
        projectdirs = db.get_project_dirs()
        for projectdir in projectdirs:
            print("Updating '{}'".format(projectdir))
            with local.cwd(projectdir):
                if self.find:
                    pnldash('find')
                pnldash('status')
                pnldash('push')


def _print_map(d, prepend='', keys=None, fd=sys.stderr):
    if not keys:
        keys = d.keys()
    for k in keys:
        fd.write("{}{:<25} {:<15}".format(prepend, k, d[k]) + '\n')


@App.subcommand("env")
class Env(cli.Application):
    """Print the bash environment setup for a project's data paths."""

    paramid = cli.SwitchAttr(
        ['-p', '--paramid'],
        int,
        default=0,
        help="The index of the pipeline whose paths you want")

    #TODO make unset option?

    def main(self, name):
        def escape(filepath):
            return filepath.__str__().replace('(', '\(').replace(')', '\)')

        # TODO be able to select projects with same names
        projectdir, yml = db.get_projects(name)[0]

        print("# param id #{} (there are a total of {} pipeline(s))".format(
            self.paramid, len(yml['pipelines'])))
        _print_map(yml['pipelines'][self.paramid]['parameters'], prepend='# ')
        print('')
        print("export root={}".format(projectdir))
        paths = yml['pipelines'][self.paramid]['paths']
        for key, path in paths.items():
            if key == 'caselist':
                continue
            print("export {}={}".format(key, escape(path)))


@App.subcommand("list")
class List(cli.Application):
    """List the project names in the central database"""

    def main(self):
        for projectdir, yml in db.get_projects():
            numpipelines = len(yml['pipelines'])
            print(yml['name'] + " ({}) ({} pipeline(s))".format(projectdir,
                                                                numpipelines))


@App.subcommand("show")
class Show(cli.Application):
    """Show the project.yml contents for a project."""

    def main(self, name):
        # TODO be able to select projects with same names
        projectdir, yml = db.get_projects(name)[0]
        print("# {} ({})".format(yml['name'], projectdir))
        print
        print("## Description\n")
        print(yml['description\n'])
        print("## Pipelines\n")
        pprint(yml['pipelines'])


if __name__ == '__main__':
    App.run()
